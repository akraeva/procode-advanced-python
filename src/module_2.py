# Stepick.org — PROкод: продвинутый курс по Python
# 2. Освежаем базовые знания

from sys import stdin
import re

# pylint: disable=W0105

# 2.1 Объявление переменных, ввод (input()) и вывод (print())

# === Задача 1. Пересекаются ли встречи ===
"""
    Даны времена начала и конца двух встреч в минутах от начала дня.
    Считайте четыре целых числа (по одному в строке):
    start1, end1, start2, end2.
    Считаем, что встречи пересекаются, если у них есть общий промежуток
    положительной длины (простое касание концами,
    как end1 == start2, --> не пересечение).
    Если встречи пересекаются, выведите на отдельных строках:
    - Да
    - вторую встречу, преобразованную в формат ЧЧ:ММ - ЧЧ:ММ (с ведущими нулями).
    Если не пересекаются --> выведите только Нет.
    Гарантируется, что значения не превышают 24 часа (0–1440).
    Функция range() недоступна в этой задаче.
    """


def m_2_1_1(data):
    start1, end1, start2, end2 = map(int, data.split("\n"))
    if end1 <= start2:
        return "Нет"
    else:
        res = f"{start2//60:02}:{start2 % 60:02} - {end2//60:02}:{end2 % 60:02}"
        return f"Да\n{res}"

    # print(m_2_1_1(stdin.read()))


# === Задача 2. Делим фрукты поровну ===
"""
    Считайте из ввода два целых числа (по одному в строке):
    сначала количество яблок, затем количество бананов.
    Вычислите общее число фруктов и выведите две строки:
    Общее количество фруктов: <сумма>
    Каждому другу достанется по <поровну> фруктов. -->
    где <поровну> равно половине от общей суммы.
    Функция range() недоступна для использования в этой задаче.
    """


def m_2_1_2(apples, bananas):
    str_1 = f"Общее количество фруктов: {apples+bananas}"
    str_2 = f"Каждому другу достанется по {(apples+bananas)//2} фруктов."
    return "\n".join((str_1, str_2))

    # print(m_2_1_2(int(input()), int(input())))


# === Задача 3. Секретное письмо мага ===
"""
    Считайте три значения (по одному в строке):
    - имя мага --> строка;
    - возраст --> целое число;
    - любимое число --> целое число.
    Вычислите секретный код по формуле:
    (возраст + любимое_число) * длина_имени
    Выведите результат в формате:
    Секретный код: <код>
    Функция range() недоступна для использования в этой задаче.
    """


def m_2_1_3(name, age, number):
    return f"Секретный код: {(age+number)*len(name)}"

    # print(m_2_1_3(input(), int(input()), int(input())))


# === Задача 4. Идеальный код замка ===
"""
    Считайте два значения (каждое с новой строки):
    - имя пользователя --> строка (имя может состоять из
    нескольких слов через пробел);
    - любимое число --> целое число.
    Вычислите:
    - сумму цифр любимого числа;
    - количество букв в имени, игнорируя пробелы.
    Выведите результат в формате:
    Код замка: <сумма_цифр>-<количество_букв>
    Функция range() недоступна для использования в этой задаче.
    """


def m_2_1_4(name, number):
    number_sum = sum(int(x) for x in number)
    name_sum = sum(len(word) for word in name.split())
    return f"Код замка: {number_sum}-{name_sum}"

    # print(m_2_1_4(input(), input()))


# === Задача 5. Прорыв в будущее ===
"""
    Считайте четыре значения (каждое с новой строки):
    - текущий год --> целое число;
    - количество лет для подготовки --> целое число;
    - число технологического развития --> целое число;
    - название проекта --> строка.

    Вычислите «индекс инноваций» по формуле:
    индекс = (сумма цифр числа из пункта 3) + (количество символов в названии без пробелов)
    Вычислите год прорыва:
    год_прорыва = текущий_год + (количество_лет * индекс)

    Выведите результат в формате: Год прорыва: <число>
    """


def m_2_1_5(*args):
    current_year = int(args[0])
    number_of_years = int(args[1])
    tech_number = int(args[2])
    project_name = args[3]
    innovation_index = sum(int(digit) for digit in str(tech_number)) + len(
        project_name.replace(" ", "")
    )
    breakthrough = current_year + number_of_years * innovation_index
    return f"Год прорыва: {breakthrough}"

    # data = stdin.read().split("\n")
    # print(m_2_1_5(*data))


# 2.2 Основные типы данных (int, float, str, bool)

# === Задача 1. Определение типа данных ===
"""
    Ты создаёшь универсальный ввод: пользователь печатает любые значения,
    а программа сама распознаёт их типы и сообщает результат.
    Считайте четыре значения (каждое с новой строки). Значения могут быть
    строками, числами или булевыми константами.
    Определите тип каждого введённого значения и выведите четыре строки в формате:
    Тип первого значения: <тип>
    Тип второго значения: <тип>
    Тип третьего значения: <тип>
    Тип четвертого значения: <тип>
    Где <тип> это результат вызова type(...), например <class 'int'>.

    """


# from sys import stdin


def m_2_2_1(*args):

    def detect_type(a):
        if a in ("True", "False"):
            return "bool"
        try:
            int(a)
            return "int"
        except ValueError:
            try:
                float(a)
                return "float"
            except ValueError:
                return "str"

    nums = ["первого", "второго", "третьего", "четвертого"]
    res = [
        f"Тип {num} значения: <class '{detect_type(arg)}'>"
        for num, arg in zip(nums, args)
    ]
    return "\n".join(res)

    # data = (line.strip() for line in stdin)
    # print(m_2_2_1(*data))


# === Задача 2. Золото пиратов и их доли ===
"""
    Считайте два целых числа (каждое с новой строки):
    - общее количество монет;
    - количество пиратов.
    Сначала вычтите 10% от общего числа монет, это расходы на ремонт.
    Оставшиеся монеты поделите между пиратами поровну и определите остаток.

    Выведите три строки строго в таком виде:
    Монеты на расходы: <число>
    Каждый пират получит <число> монет.
    Останется <число> монет.
    Слово «монет» в выводе остаётся неизменным, независимо от количества.
    """


def m_2_2_2(coins, pirates):
    expenses = coins // 10
    pirate = (coins - expenses) // pirates
    balance = (coins - expenses) % pirates
    res = f"Монеты на расходы: {expenses}\nКаждый пират получит {pirate} монет.\nОстанется {balance} монет."
    return res

    # print(m_2_2_2(int(input()), int(input())))


# === Задача 3. Кто лучше охраняет замок ===
"""
    Считайте два целых числа (каждое с новой строки):
    - площадь участка Виктора;
    - площадь участка Михаила.
    Выведите одну из строк:
    Виктор охраняет больше --> если площадь Виктора больше площади Михаила;
    Михаил охраняет больше --> если площадь Михаила больше площади Виктора;
    Они охраняют одинаковые участки --> если площади равны.
    Если оба охраняли участок не больше 100 кв. м, дополнительно выведите строку:
    Ни у кого из стражей нет участка больше 100 квадратных метров
    """


def m_2_2_3(victor: int, mikhail: int):
    supplement = "Ни у кого из стражей нет участка больше 100 квадратных метров"
    if victor > mikhail:
        res = "Виктор охраняет больше"
    elif victor < mikhail:
        res = "Михаил охраняет больше"
    else:
        res = "Они охраняют одинаковые участки"
    if victor <= 100 and mikhail <= 100:
        res += "\n" + supplement
    return res

    # print(m_2_2_3(int(input()), int(input())))


# === Задача 4. Инопланетное смешение данных с ошибкой ввода ===
"""
    Считайте одну строку с несколькими элементами, разделёнными пробелами.
    Для каждого элемента определите тип и выведите его на новой строке.
    Допустимые типы:
    - целое число → int;
    - вещественное число с точкой (например, 0.5, 99.99) → float;
    - булево значение True или False (без кавычек) → bool;
    - строка в двойных кавычках → str.
    Если элемент нельзя отнести ни к одному из допустимых типов, выведите:
    Неверный тип данных
    """


def m_2_2_4(data: str):
    def detect_type(a: str):
        if a in ("True", "False"):
            return "bool"
        if a[0] in ("'\"") and a[0] == a[-1]:
            return "str"
        try:
            int(a)
            return "int"
        except ValueError:
            try:
                float(a)
                return "float"
            except ValueError:
                return "Неверный тип данных"

    res = (detect_type(d) for d in data.split())
    return "\n".join(res)

    # print(m_2_2_4(input()))


# === Задача 5. Арифметическая битва у волшебника ===
"""
    Считайте два целых числа из одной строки через пробел:
    первое для Десятикома, второе для Половинника.
    Выполните операции:
    - Десятиком: умножьте своё число на 2;
    - Половинник: разделите своё число на 2.
    Сравните полученные значения и выведите ровно одну строку:
    Победил Десятиком! --> если результат Десятикома больше;
    Победил Половинник! --> если результат Половинника больше;
    Ничья! Числа равны. --> если результаты равны.
    """


def m_2_2_5(data: str):
    ten, half = map(int, data.split())
    ten *= 2
    half /= 2
    if ten > half:
        return "Победил Десятиком!"
    elif ten < half:
        return "Победил Половинник!"
    else:
        return "Ничья! Числа равны."

    # print(m_2_2_5(input()))


# === Задача 6. Питомец-Счётчик на миссии ===
"""
    Считай одно целое число --> стартовую позицию Счётчика.
    Выполни шаги в точном порядке:
    - умножь число на 2;
    --- если исходное число нечётное --> умножь текущее значение ещё на 3;
    --- если исходное число чётное --> раздели текущее значение на 3;
    - раздели текущее значение на 2;
    - прибавь 5.
    Выведи итог в формате:
    Конечная позиция Счетчика: <число>
    Используй целочисленное деление (//) во всех операциях деления.
    """


def m_2_2_6(num: int):
    res = num * 2
    res = (res * 3 if num % 2 != 0 else res // 3) // 2 + 5
    return f"Конечная позиция Счетчика: {res}"

    # print(m_2_2_6(int(input())))


# 2.3 Работа со строками: индексация, методы, форматирование

# === Задача 1. Проверка на валидность пароля ===
"""
    Считай одну строку --> пароль.
    Проверь, что одновременно выполняются три условия:
    - пароль начинается с буквы;
    - пароль состоит только из букв и цифр;
    - длина пароля не менее 8 символов.
    Выведи одну строку:
    - Пароль принят! --> если все условия выполнены;
    - Пароль не принят! --> иначе.
    """


def m_2_3_1(password: str):
    simbols = all(ch.isalpha() or ch.isdigit() for ch in password)
    if password[0].isalpha() and simbols and len(password) >= 8:
        return "Пароль принят!"
    return "Пароль не принят!"


# print(m_2_3_1(input()))


# === Задача 2. Древний манускрипт ===
"""
    Считайте одну строку --> текст манускрипта.
    Переверните строку с помощью среза и выведите результат в верхнем регистре.
    """


def m_2_3_2(text: str):
    return text.upper()[::-1]


# print(m_2_3_2(input()))

# === Задача 3. Тайна древнего письма ===
"""
    Считайте одну строку --> зашифрованное сообщение.
    Последовательно выполните:
    - Переверните строку и сохраните результат в переменной rev.
    В rev должна быть ровно исходная строка, перевёрнутая посимвольно,
    без удаления символов и без изменения регистра.
    Важно: дальше rev не изменяйте. Для последующих шагов используйте другие переменные.
    - удалите все пробелы и лишние символы (оставьте только буквы и/или цифры);
    - преобразуйте результат в верхний регистр;
    - проверьте, является ли полученная строка палиндромом.
    Выведите:
    - Тайна разгадана, если строка является палиндромом;
    - Тайна не разгадана --> в противном случае.
    """

# import re

rev = None


def m_2_3_3(message: str):
    global rev
    rev = message[::-1]
    res = re.sub(r"[^A-ZА-Я0-9]", "", message.upper())
    return "Тайна разгадана" if res == res[::-1] else "Тайна не разгадана"


# print(m_2_3_3(input()))

# === Задача 4. Чапаев и шифровка сообщений ===
"""
    Считайте одну строку --> зашифрованное сообщение.
    Выполните обратные шаги шифрования в строгом порядке:
    - переверните строку;
    - замените все символы _ на пробелы;
    - верните каждую букву на одну позицию назад в алфавите
      (для русского алфавита с учётом кольца и регистра:
      А ← Б, …, Я ← А; для строчных --> аналогично).
      Выведите две строки:
    - первая строка --> расшифрованное сообщение;
    - вторая строка:
        - Чапаев, приказ выполнен! -->
          если в расшифровке встречается слово АРМИЯ;
        - Чапаев, действуй быстро, шифр не раскрыт! -->
          если слова АРМИЯ нет.
    """


def m_2_3_4(message: str):
    result = ""
    for ch in message[::-1].replace("_", " "):
        if ch.isalpha():
            result += chr(ord(ch) + (-1 if ch.lower() != "а" else 31))
        else:
            result += ch
    second_srting = (
        "Чапаев, приказ выполнен!"
        if "АРМИЯ" in result
        else "Чапаев, действуй быстро, шифр не раскрыт!"
    )
    return f"{result}\n{second_srting}"


# print(m_2_3_4(input()))


# === Задача 5. Тайный код: поиск магии и преобразование ===
"""
    Считай одну строку --> код.
    Сначала подсчитай, сколько раз в строке встречается слово магия без учёта
    регистра (считай именно отдельное слово).
    Далее, в зависимости от количества найденных слов:
    - если количество чётное (включая 0) -->
        удали все пробелы из исходной строки и переверни получившуюся строку;
    - если количество нечётное -->
        из исходной строки извлеки все символы, которые встречаются ровно один
        раз (учитывай регистр), сохранив их исходный порядок.
    Выведи две строки:
        Магия найдена <число> раз(а).
        Результат: <полученная_строка>
    """

# import re


def m_2_3_5(code: str):
    count = len(re.findall(r"\bмагия\b", code.lower()))
    if count % 2 == 0:
        result = code.replace(" ", "")[::-1]
    else:
        result = "".join(ch for ch in code if code.count(ch) == 1)
    return f"Магия найдена {count} раз(а).\nРезультат: {result}"


# print(m_2_3_5(input()))


# === Задача 6. Расшифровка с помощью срезов ===
"""
    Считайте:
    - строку encrypted_message --> зашифрованное сообщение;
    - целое число n --> количество срезов;
    - далее n строк, в каждой два целых числа start end
      (индексы могут быть отрицательными).

    Для каждого среза выполните по порядку:
    - извлеките подстроку по правилам Python-среза s[start:end]
      (конечный индекс не включается) и выведите её на отдельной строке;
    - удалите извлечённую подстроку из текущего сообщения;
    - следующий срез делайте уже из обновлённой строки.
    Если срез пустой, выведите пустую строку (пустую строку также
    нужно учитывать как результат шага).
    """
# from sys import stdin


def m_2_3_6(message: str, n: int, *args):
    slices = ([int(num) for num in arg.strip().split()] for arg in args)
    string = message
    res = []
    for start, end in slices:
        res.append(string[start:end])
        string = string[:start] + string[end:]
    return "\n".join(res)


# print(m_2_3_6(input(), int(input()), *stdin.readlines()))
