# Stepick.org — PROкод: продвинутый курс по Python
# 2. Освежаем базовые знания

from sys import stdin
import re

# pylint: disable=W0105

# 2.1 Объявление переменных, ввод (input()) и вывод (print())

# === Задача 1. Пересекаются ли встречи ===
"""
    Даны времена начала и конца двух встреч в минутах от начала дня.
    Считайте четыре целых числа (по одному в строке):
    start1, end1, start2, end2.
    Считаем, что встречи пересекаются, если у них есть общий промежуток
    положительной длины (простое касание концами,
    как end1 == start2, --> не пересечение).
    Если встречи пересекаются, выведите на отдельных строках:
    - Да
    - вторую встречу, преобразованную в формат ЧЧ:ММ - ЧЧ:ММ (с ведущими нулями).
    Если не пересекаются --> выведите только Нет.
    Гарантируется, что значения не превышают 24 часа (0–1440).
    Функция range() недоступна в этой задаче.
    """


def m_2_1_1(data):
    start1, end1, start2, end2 = map(int, data.split("\n"))
    if end1 <= start2:
        return "Нет"
    else:
        res = f"{start2//60:02}:{start2 % 60:02} - {end2//60:02}:{end2 % 60:02}"
        return f"Да\n{res}"

    # print(m_2_1_1(stdin.read()))


# === Задача 2. Делим фрукты поровну ===
"""
    Считайте из ввода два целых числа (по одному в строке):
    сначала количество яблок, затем количество бананов.
    Вычислите общее число фруктов и выведите две строки:
    Общее количество фруктов: <сумма>
    Каждому другу достанется по <поровну> фруктов. -->
    где <поровну> равно половине от общей суммы.
    Функция range() недоступна для использования в этой задаче.
    """


def m_2_1_2(apples, bananas):
    str_1 = f"Общее количество фруктов: {apples+bananas}"
    str_2 = f"Каждому другу достанется по {(apples+bananas)//2} фруктов."
    return "\n".join((str_1, str_2))

    # print(m_2_1_2(int(input()), int(input())))


# === Задача 3. Секретное письмо мага ===
"""
    Считайте три значения (по одному в строке):
    - имя мага --> строка;
    - возраст --> целое число;
    - любимое число --> целое число.
    Вычислите секретный код по формуле:
    (возраст + любимое_число) * длина_имени
    Выведите результат в формате:
    Секретный код: <код>
    Функция range() недоступна для использования в этой задаче.
    """


def m_2_1_3(name, age, number):
    return f"Секретный код: {(age+number)*len(name)}"

    # print(m_2_1_3(input(), int(input()), int(input())))


# === Задача 4. Идеальный код замка ===
"""
    Считайте два значения (каждое с новой строки):
    - имя пользователя --> строка (имя может состоять из
    нескольких слов через пробел);
    - любимое число --> целое число.
    Вычислите:
    - сумму цифр любимого числа;
    - количество букв в имени, игнорируя пробелы.
    Выведите результат в формате:
    Код замка: <сумма_цифр>-<количество_букв>
    Функция range() недоступна для использования в этой задаче.
    """


def m_2_1_4(name, number):
    number_sum = sum(int(x) for x in number)
    name_sum = sum(len(word) for word in name.split())
    return f"Код замка: {number_sum}-{name_sum}"

    # print(m_2_1_4(input(), input()))


# === Задача 5. Прорыв в будущее ===
"""
    Считайте четыре значения (каждое с новой строки):
    - текущий год --> целое число;
    - количество лет для подготовки --> целое число;
    - число технологического развития --> целое число;
    - название проекта --> строка.

    Вычислите «индекс инноваций» по формуле:
    индекс = (сумма цифр числа из пункта 3) + (количество символов в названии без пробелов)
    Вычислите год прорыва:
    год_прорыва = текущий_год + (количество_лет * индекс)

    Выведите результат в формате: Год прорыва: <число>
    """


def m_2_1_5(*args):
    current_year = int(args[0])
    number_of_years = int(args[1])
    tech_number = int(args[2])
    project_name = args[3]
    innovation_index = sum(int(digit) for digit in str(tech_number)) + len(
        project_name.replace(" ", "")
    )
    breakthrough = current_year + number_of_years * innovation_index
    return f"Год прорыва: {breakthrough}"

    # data = stdin.read().split("\n")
    # print(m_2_1_5(*data))


# 2.2 Основные типы данных (int, float, str, bool)

# === Задача 1. Определение типа данных ===
"""
    Ты создаёшь универсальный ввод: пользователь печатает любые значения,
    а программа сама распознаёт их типы и сообщает результат.
    Считайте четыре значения (каждое с новой строки). Значения могут быть
    строками, числами или булевыми константами.
    Определите тип каждого введённого значения и выведите четыре строки в формате:
    Тип первого значения: <тип>
    Тип второго значения: <тип>
    Тип третьего значения: <тип>
    Тип четвертого значения: <тип>
    Где <тип> это результат вызова type(...), например <class 'int'>.

    """


# from sys import stdin


def m_2_2_1(*args):

    def detect_type(a):
        if a in ("True", "False"):
            return "bool"
        try:
            int(a)
            return "int"
        except ValueError:
            try:
                float(a)
                return "float"
            except ValueError:
                return "str"

    nums = ["первого", "второго", "третьего", "четвертого"]
    res = [
        f"Тип {num} значения: <class '{detect_type(arg)}'>"
        for num, arg in zip(nums, args)
    ]
    return "\n".join(res)

    # data = (line.strip() for line in stdin)
    # print(m_2_2_1(*data))


# === Задача 2. Золото пиратов и их доли ===
"""
    Считайте два целых числа (каждое с новой строки):
    - общее количество монет;
    - количество пиратов.
    Сначала вычтите 10% от общего числа монет, это расходы на ремонт.
    Оставшиеся монеты поделите между пиратами поровну и определите остаток.

    Выведите три строки строго в таком виде:
    Монеты на расходы: <число>
    Каждый пират получит <число> монет.
    Останется <число> монет.
    Слово «монет» в выводе остаётся неизменным, независимо от количества.
    """


def m_2_2_2(coins, pirates):
    expenses = coins // 10
    pirate = (coins - expenses) // pirates
    balance = (coins - expenses) % pirates
    res = f"Монеты на расходы: {expenses}\nКаждый пират получит {pirate} монет.\nОстанется {balance} монет."
    return res

    # print(m_2_2_2(int(input()), int(input())))


# === Задача 3. Кто лучше охраняет замок ===
"""
    Считайте два целых числа (каждое с новой строки):
    - площадь участка Виктора;
    - площадь участка Михаила.
    Выведите одну из строк:
    Виктор охраняет больше --> если площадь Виктора больше площади Михаила;
    Михаил охраняет больше --> если площадь Михаила больше площади Виктора;
    Они охраняют одинаковые участки --> если площади равны.
    Если оба охраняли участок не больше 100 кв. м, дополнительно выведите строку:
    Ни у кого из стражей нет участка больше 100 квадратных метров
    """


def m_2_2_3(victor: int, mikhail: int):
    supplement = "Ни у кого из стражей нет участка больше 100 квадратных метров"
    if victor > mikhail:
        res = "Виктор охраняет больше"
    elif victor < mikhail:
        res = "Михаил охраняет больше"
    else:
        res = "Они охраняют одинаковые участки"
    if victor <= 100 and mikhail <= 100:
        res += "\n" + supplement
    return res

    # print(m_2_2_3(int(input()), int(input())))


# === Задача 4. Инопланетное смешение данных с ошибкой ввода ===
"""
    Считайте одну строку с несколькими элементами, разделёнными пробелами.
    Для каждого элемента определите тип и выведите его на новой строке.
    Допустимые типы:
    - целое число → int;
    - вещественное число с точкой (например, 0.5, 99.99) → float;
    - булево значение True или False (без кавычек) → bool;
    - строка в двойных кавычках → str.
    Если элемент нельзя отнести ни к одному из допустимых типов, выведите:
    Неверный тип данных
    """


def m_2_2_4(data: str):
    def detect_type(a: str):
        if a in ("True", "False"):
            return "bool"
        if a[0] in ("'\"") and a[0] == a[-1]:
            return "str"
        try:
            int(a)
            return "int"
        except ValueError:
            try:
                float(a)
                return "float"
            except ValueError:
                return "Неверный тип данных"

    res = (detect_type(d) for d in data.split())
    return "\n".join(res)

    # print(m_2_2_4(input()))


# === Задача 5. Арифметическая битва у волшебника ===
"""
    Считайте два целых числа из одной строки через пробел:
    первое для Десятикома, второе для Половинника.
    Выполните операции:
    - Десятиком: умножьте своё число на 2;
    - Половинник: разделите своё число на 2.
    Сравните полученные значения и выведите ровно одну строку:
    Победил Десятиком! --> если результат Десятикома больше;
    Победил Половинник! --> если результат Половинника больше;
    Ничья! Числа равны. --> если результаты равны.
    """


def m_2_2_5(data: str):
    ten, half = map(int, data.split())
    ten *= 2
    half /= 2
    if ten > half:
        return "Победил Десятиком!"
    elif ten < half:
        return "Победил Половинник!"
    else:
        return "Ничья! Числа равны."

    # print(m_2_2_5(input()))


# === Задача 6. Питомец-Счётчик на миссии ===
"""
    Считай одно целое число --> стартовую позицию Счётчика.
    Выполни шаги в точном порядке:
    - умножь число на 2;
    --- если исходное число нечётное --> умножь текущее значение ещё на 3;
    --- если исходное число чётное --> раздели текущее значение на 3;
    - раздели текущее значение на 2;
    - прибавь 5.
    Выведи итог в формате:
    Конечная позиция Счетчика: <число>
    Используй целочисленное деление (//) во всех операциях деления.
    """


def m_2_2_6(num: int):
    res = num * 2
    res = (res * 3 if num % 2 != 0 else res // 3) // 2 + 5
    return f"Конечная позиция Счетчика: {res}"

    # print(m_2_2_6(int(input())))


# 2.3 Работа со строками: индексация, методы, форматирование

# === Задача 1. Проверка на валидность пароля ===
"""
    Считай одну строку --> пароль.
    Проверь, что одновременно выполняются три условия:
    - пароль начинается с буквы;
    - пароль состоит только из букв и цифр;
    - длина пароля не менее 8 символов.
    Выведи одну строку:
    - Пароль принят! --> если все условия выполнены;
    - Пароль не принят! --> иначе.
    """


def m_2_3_1(password: str):
    simbols = all(ch.isalpha() or ch.isdigit() for ch in password)
    if password[0].isalpha() and simbols and len(password) >= 8:
        return "Пароль принят!"
    return "Пароль не принят!"


# print(m_2_3_1(input()))


# === Задача 2. Древний манускрипт ===
"""
    Считайте одну строку --> текст манускрипта.
    Переверните строку с помощью среза и выведите результат в верхнем регистре.
    """


def m_2_3_2(text: str):
    return text.upper()[::-1]


# print(m_2_3_2(input()))

# === Задача 3. Тайна древнего письма ===
"""
    Считайте одну строку --> зашифрованное сообщение.
    Последовательно выполните:
    - Переверните строку и сохраните результат в переменной rev.
    В rev должна быть ровно исходная строка, перевёрнутая посимвольно,
    без удаления символов и без изменения регистра.
    Важно: дальше rev не изменяйте. Для последующих шагов используйте другие переменные.
    - удалите все пробелы и лишние символы (оставьте только буквы и/или цифры);
    - преобразуйте результат в верхний регистр;
    - проверьте, является ли полученная строка палиндромом.
    Выведите:
    - Тайна разгадана, если строка является палиндромом;
    - Тайна не разгадана --> в противном случае.
    """

# import re

rev = None


def m_2_3_3(message: str):
    global rev
    rev = message[::-1]
    res = re.sub(r"[^A-ZА-Я0-9]", "", message.upper())
    return "Тайна разгадана" if res == res[::-1] else "Тайна не разгадана"


# print(m_2_3_3(input()))

# === Задача 4. Чапаев и шифровка сообщений ===
"""
    Считайте одну строку --> зашифрованное сообщение.
    Выполните обратные шаги шифрования в строгом порядке:
    - переверните строку;
    - замените все символы _ на пробелы;
    - верните каждую букву на одну позицию назад в алфавите
      (для русского алфавита с учётом кольца и регистра:
      А ← Б, …, Я ← А; для строчных --> аналогично).
      Выведите две строки:
    - первая строка --> расшифрованное сообщение;
    - вторая строка:
        - Чапаев, приказ выполнен! -->
          если в расшифровке встречается слово АРМИЯ;
        - Чапаев, действуй быстро, шифр не раскрыт! -->
          если слова АРМИЯ нет.
    """


def m_2_3_4(message: str):
    result = ""
    for ch in message[::-1].replace("_", " "):
        if ch.isalpha():
            result += chr(ord(ch) + (-1 if ch.lower() != "а" else 31))
        else:
            result += ch
    second_srting = (
        "Чапаев, приказ выполнен!"
        if "АРМИЯ" in result
        else "Чапаев, действуй быстро, шифр не раскрыт!"
    )
    return f"{result}\n{second_srting}"


# print(m_2_3_4(input()))


# === Задача 5. Тайный код: поиск магии и преобразование ===
"""
    Считай одну строку --> код.
    Сначала подсчитай, сколько раз в строке встречается слово магия без учёта
    регистра (считай именно отдельное слово).
    Далее, в зависимости от количества найденных слов:
    - если количество чётное (включая 0) -->
        удали все пробелы из исходной строки и переверни получившуюся строку;
    - если количество нечётное -->
        из исходной строки извлеки все символы, которые встречаются ровно один
        раз (учитывай регистр), сохранив их исходный порядок.
    Выведи две строки:
        Магия найдена <число> раз(а).
        Результат: <полученная_строка>
    """

# import re


def m_2_3_5(code: str):
    count = len(re.findall(r"\bмагия\b", code.lower()))
    if count % 2 == 0:
        result = code.replace(" ", "")[::-1]
    else:
        result = "".join(ch for ch in code if code.count(ch) == 1)
    return f"Магия найдена {count} раз(а).\nРезультат: {result}"


# print(m_2_3_5(input()))


# === Задача 6. Расшифровка с помощью срезов ===
"""
    Считайте:
    - строку encrypted_message --> зашифрованное сообщение;
    - целое число n --> количество срезов;
    - далее n строк, в каждой два целых числа start end
      (индексы могут быть отрицательными).

    Для каждого среза выполните по порядку:
    - извлеките подстроку по правилам Python-среза s[start:end]
      (конечный индекс не включается) и выведите её на отдельной строке;
    - удалите извлечённую подстроку из текущего сообщения;
    - следующий срез делайте уже из обновлённой строки.
    Если срез пустой, выведите пустую строку (пустую строку также
    нужно учитывать как результат шага).
    """
# from sys import stdin


def m_2_3_6(message: str, n: int, *args):
    slices = ([int(num) for num in arg.strip().split()] for arg in args)
    string = message
    res = []
    for start, end in slices:
        res.append(string[start:end])
        string = string[:start] + string[end:]
    return "\n".join(res)


# print(m_2_3_6(input(), int(input()), *stdin.readlines()))

# 2.4 Условные и логические операторы

# === Задача 1. Выбор оружия для героя ===
"""
    Считайте два целых числа (каждое с новой строки):
    - уровень силы героя;
    - опыт сражений героя.
    Выведите ровно одну строку по правилам:
    - если уровень силы меньше 50 → Выберите меч!
    - если уровень силы от 50 до 100 включительно 
      и опыт меньше 20 → Выберите лук и стрелы!
    - если уровень силы от 50 до 100 включительно
      и опыт 20 или больше → Выберите магический посох!
    - если уровень силы больше 100 → Выберите любое оружие на ваш выбор!
    """


def m_2_4_1(level: int, experience: int):
    if level < 50:
        return "Выберите меч!"
    if level <= 100:
        if experience < 20:
            return "Выберите лук и стрелы!"
        else:
            return "Выберите магический посох!"
    return "Выберите любое оружие на ваш выбор!"


# print(m_2_4_1(int(input()), int(input())))


# === Задача 2. Что надеть туристу сегодня ===
"""
    Считайте одно целое число --> температуру воздуха в °C.
    Выведите ровно одну строку по правилам:
    - если температура ниже 0 → Наденьте зимнюю куртку.
    - если температура от 0 до 15 включительно → Наденьте лёгкую куртку.
    - если температура выше 15 → Наденьте футболку.
    """


def m_2_4_2(temp: int):
    if temp < 0:
        return "Наденьте зимнюю куртку."
    elif temp <= 15:
        return "Наденьте лёгкую куртку."
    return "Наденьте футболку."


# print(m_2_4_2(int(input())))


# === Задача 3. Покупки героя в HoMM III ===
"""
    Считайте одно целое число --> количество монет у героя.
    Выведите ровно одну строку по правилам:
    - если монет больше 1000 → Герой может купить замок.
    - если монет от 500 до 1000 включительно → Герой может купить армию.
    - если монет меньше 500 → Герой может купить несколько
      предметов или артефактов.
    Используйте конструкцию match-case.
    """


def m_2_4_3(coins: int):
    match coins:
        case c if c > 1000:
            return "Герой может купить замок."
        case c if c >= 500:
            return "Герой может купить армию."
        case _:
            return "Герой может купить несколько предметов или артефактов."


# print(m_2_4_3(int(input())))


# === Задача 4. В лесу у Людоедов ===
"""
Считайте два значения (каждое с новой строки):
- время суток --> день или ночь;
- ответ на вопрос --> да или нет.
Выведите ровно одну строку по правилам:
- если сейчас день и ответ да → Людоеды съели вас.
- если сейчас день и ответ нет → Вы прошли в деревню.
- если сейчас ночь и ответ да → Людоеды поймали вас.
-если сейчас ночь и ответ нет → Вы прошли в деревню.
"""


def m_2_4_4(time: str, answer: str):
    match (time, answer):
        case ("день", "да"):
            return "Людоеды съели вас."
        case ("ночь", "да"):
            return "Людоеды поймали вас."
        case (_, "нет"):
            return "Вы прошли в деревню."


# print(m_2_4_4(input(), input()))


# 2.5 Циклы: for, while, использование break и continue

# === Задача 1. Первые следы ===
"""
    Считайте одну строку список сигналов, записанных через запятую
    (пробелы вокруг запятых могут присутствовать). Проверьте, есть ли
    среди сигналов слово danger (именно так, в нижнем регистре).
    Выведите:
    След обнаружен! Мы нашли сигнал тревоги: danger -->
        если сигнал присутствует;
    Сигнал тревоги не найден. Мы продолжаем поиски. -->
        если сигнала нет.
    """


def m_2_5_1(text: str):
    if "danger" in text:
        return "След обнаружен! Мы нашли сигнал тревоги: danger"
    return "Сигнал тревоги не найден. Мы продолжаем поиски."


# print(m_2_5_1(input()))

# === Задача 2.  Новые следы ===
"""
    Считай одну строку --> список сигналов, разделённых запятыми
    (пробелы вокруг запятых могут быть).
    Обрабатывай сигналы по порядку в цикле while.
    Для каждого элемента:
    если он равен ignore --> выведи строку ignore и увеличь счётчик;
    затем продолжай проверку следующих сигналов (другие сигналы не выводи).
    В конце выведи итоговое количество встреченных ignore на отдельной строке.
    """


def m_2_5_2(text: str):
    data = text.split(",")
    counter = 0
    while data:
        if data.pop().strip() == "ignore":
            counter += 1
    return "ignore\n" * counter + str(counter)


# print(m_2_5_2(input()))

# === Задача 3. Поиск монстра в лесу ===
"""
    Считайте одну строку --> список имён монстров, разделённых пробелами.
    Найдите первого монстра, который встречается в списке ровно один раз.
    Если такого нет, выведите: Нет новых монстров.
    """


def m_2_5_3(text: str):
    monstrs = text.split()
    for monstr in monstrs:
        if monstrs.count(monstr) == 1:
            return monstr
    return "Нет новых монстров"


# print(m_2_5_3(input()))

# === Задача 4. Ожидание у ловушки ===
"""
    Считайте одну строку --> звуки, записанные через пробел.
    Последовательно просматривайте звуки слева направо и игнорируйте все,
    которые не совпадают с известными звуками монстров.
    Как только встретится первый звук из списка ниже, выведите сообщение
    и завершите работу:
        - Шшшшшш → Вампир
        - Аууууу → Вурдалак
        - Рррррр → Оборотень
        - Уууууу → Призрак
        - Гррррр → Демон
    Формат вывода: при обнаружении монстра: Монстр пойман! Это <имя_монстра>!
    если ни один звук монстра не встретился: Пока тихо, наблюдаем!
    """


def m_2_5_4(text: str):
    sounds = {
        "Шшшшшш": "Вампир",
        "Аууууу": "Вурдалак",
        "Рррррр": "Оборотень",
        "Уууууу": "Призрак",
        "Гррррр": "Демон",
    }
    for monstr in text.split():
        if monstr in sounds:
            return f"Монстр пойман! Это {sounds[monstr]}!"
    return "Пока тихо, наблюдаем!"


# print(m_2_5_4(input()))


# === Задача 5. Ожидание у ловушки ===
"""
    Считай одну строку --> звуки, записанные через пробел.
    Просматривай звуки слева направо и игнорируй всё, что не
    является звуком монстра. Как только встретится первый звук монстра,
    выведи сообщение о начале битвы и начни пошаговый бой;
    после победы завершай программу.
    Звуки монстров (с учётом регистра) и их жизни:
        Шшшшшш → Вампир (10 жизней)
        Аууууу → Вурдалак (13 жизней)
        Рррррр → Оборотень (8 жизней)
        Уууууу → Призрак (14 жизней)
        Гррррр → Демон (21 жизнь)
    Правила боя:
        Сначала бьёт Дон, затем Сим, далее по очереди.
        Каждый удар наносит 2 урона.
        После каждого удара выводи строку в формате:
        Ход Дона: <Имя> получает 2 урона! У <Имя> осталось <k> жизней.
        или
        Ход Сима: <Имя> получает 2 урона! У <Имя> осталось <k> жизней.
    Когда жизни монстра достигают 0, выведи: <Имя> убит!
    Перед первым ходом выведи строку начала боя:
        Монстр пойман! Это <Имя>! Битва начинается!
"""


def m_2_5_5(text: str):
    res = []
    sounds = {
        "Шшшшшш": {"name": "Вампир", "lifes": 10},
        "Аууууу": {"name": "Вурдалак", "lifes": 13},
        "Рррррр": {"name": "Оборотень", "lifes": 8},
        "Уууууу": {"name": "Призрак", "lifes": 14},
        "Гррррр": {"name": "Демон", "lifes": 21},
    }
    name, lifes = None, 0
    for monstr in text.split():
        if monstr in sounds:
            name = sounds[monstr]["name"]
            lifes = sounds[monstr]["lifes"]
            break
    res.append(f"Монстр пойман! Это {name}! Битва начинается!")
    turn = True
    while lifes > 0:
        lifes -= 2
        res.append(
            f"Ход {'Дона' if turn else 'Сима'}: "
            f"{name} получает 2 урона! "
            f"У {name} осталось {max(lifes, 0)} жизней."
        )
        turn = not turn
    res.append(f"{name} убит!")
    return "\n".join(res)


# print(m_2_5_5(input()))


# === Задача 6. Неожиданный поворот ===
"""
    Инициализация боя:
        Темный Маг: 20 жизней.
        Братья: 20 жизней (на двоих).
    Команды и эффекты:
        Команды Мага (читаются на нечётных ходах):
            простая атака → Маг наносит 4 урона.
            ускоренная атака → Маг наносит 6 урона и теряет 2 жизни.
        Команды Братьев (читаются на чётных ходах):
            атака → нанести Магу 5 урона.
            защита → получить на 2 урона меньше от последней атаки Мага
                    в этом раунде и нанести Магу 3 урона.
    Порядок боя:
        -  Вводится последовательность строк, по одной на строку, чередуя
            команду Мага и команду Братьев. Ввод продолжается до окончания боя.
        - Сначала применяется действие Мага к Братьям, затем действие
            Братьев к Магу --> это один раунд.
        - В конце каждого раунда выведите две строки:
            Жизни Мага: <число>
            Жизни братьев: <число>
        - Если после раунда у Мага осталось от 1 до 3 жизней включительно,
            Маг получает +5 жизней (бонус применяется после обоих ходов
            раунда и только если Маг ещё жив).
        - Бой немедленно заканчивается, если у любой стороны жизни ≤ 0.
            Затем выведите финальную строку:
                победил Маг → Магия победила, и ваши души теперь мои!
                победили Братья → Знаешь, что хуже магии? Братья
                                  Маузеры с оружием в руках.
    Примечание: не обращайте внимания на грамматические формы в сообщениях
    о жизнях (например, «1 жизней» допустимо).
    """

# from sys import stdin


def m_2_5_6(commands):
    magician = brothers = 20
    output = []
    for i in range(0, len(commands), 2):
        m_command = commands[i].strip()
        b_command = commands[i + 1].strip() if i + 1 < len(commands) else None
        b_damage = m_damage = 0
        if m_command == "простая атака":
            b_damage -= 4
        elif m_command == "ускоренная атака":
            b_damage -= 6
            m_damage -= 2
        if brothers - b_damage > 0:
            if b_command == "атака":
                m_damage -= 5
            elif b_command == "защита":
                b_damage += 2
                m_damage -= 3
        magician += m_damage
        brothers += b_damage
        magician += 5 if 0 < magician < 4 else 0
        output.extend((f"Жизни Мага: {magician}", f"Жизни братьев: {brothers}"))
        if magician <= 0:
            output.append("Знаешь, что хуже магии? Братья Маузеры с оружием в руках.")
            break
        if brothers <= 0:
            output.append("Магия победила, и ваши души теперь мои!")
            break
    return "\n".join(output)


# print(m_2_5_6(stdin.readlines()))


# === Задача 7. Охота на вампиров: выявление уязвимостей ===
"""
    Считайте входные данные в таком порядке:
        - целое число --> количество вампиров n;
        - далее n строк формата Имя: слабость1, слабость2, ...;
        - последняя строка --> характеристики оружия,
            перечисленные через запятую.
    Для каждого вампира проверьте, есть ли хотя бы одна его слабость
    среди характеристик оружия.
    Выведите для каждого в порядке ввода ровно одну строку:
        - Вампир <Имя> уязвим для оружия! --> если совпадение есть;
        - Вампир <Имя> не уязвим для оружия! --> если совпадений нет.
"""

# from sys import stdin


def m_2_5_7(data):
    output = []
    weapons = data[-1].strip().split(", ")
    for vampire in data[1:-1]:
        info = vampire.strip().split(":")
        name = info[0].strip()
        weaknesses = [weakness in weapons for weakness in info[1].strip().split(", ")]
        output.append(
            f"Вампир {name} {'не ' if not any(weaknesses) else ''}уязвим для оружия!"
        )
    return "\n".join(output)


# print(m_2_5_7(stdin.readlines()))
