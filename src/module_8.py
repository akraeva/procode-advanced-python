# Stepick.org — PROкод: продвинутый курс по Python
# 8. Практические задания

from sys import stdin
import json
import re

# pylint: disable=W0105

# 8.1 Охота на цифрового призрака

# === Задача 1. Первый след  ===
"""
    ...Хакер оставил шифрованное сообщение на одной из взломанных платформ.
    Но кажется, это не обычный текст --> каждое слово заменено кодом!
    Требования к коду:
        - Получить словарь с расшифровкой (ключ=код, значение=слово).
        - Получить зашифрованную строку (слова-коды через пробел).
        - Заменить коды на реальные слова.
        - Ограничение: не используйте sorted
    """

# import json
# from sys import stdin


def m_8_1_1(data: str):
    line1, line2 = data.strip().split("\n")
    decoder = json.loads(line1)
    message = line2.split()
    result = (decoder[word] for word in message)
    return " ".join(result)


# print(m_8_1_1(stdin.read()))


# === Задача 2. Адрес Призрака ===
"""
    Ты нашёл список IP-адресов и подозреваешь,
    что один из них принадлежит хакеру.
    Но в этом списке много ложных следов -->
    тебе нужно найти единственный верный адрес!
    Требования к коду:
        - Получить словарь IP-адресов (ключ=адрес, значение=True/False).
        - Найти единственный IP, где значение=True.
    """

# import json


def m_8_1_2(data: str):
    addresses = json.loads(data)
    result = next(filter(lambda a: addresses[a], addresses))
    return f"Истинный адрес: {result}"


# print(m_8_1_2(input()))


# === Задача 3. Поиск сети Призрака ===
"""
    Хакер использует разные никнеймы и ID на различных платформах!
    Тебе удалось добыть базу данных, содержащую ID, ник и платформу.
    Но хакер может менять ник на разных сайтах!
    Твоя задача: найти все никнеймы и платформы, на которых он зарегистрирован.
    Требования к коду:
        - Получить словарь ID → (ник, платформа).
        - Получить ID хакера.
        - Найти все платформы и никнеймы, где он зарегистрирован.
        - Вывести список платформ и соответствующих им никнеймов.
        - Если ID не найден, вывести "ID не найден.".
    """

# import json
# from sys import stdin


def m_8_1_3(data: str):
    raw_ids, user_id = data.strip().split("\n")
    ids = json.loads(raw_ids)
    if user_id in ids:
        user_info = ids[user_id]
        result = [f"Призрак найден на {len(user_info)} платформ(ах):"]
        result.extend(f"- {platform}: {nickname}" for nickname, platform in user_info)
        return "\n".join(result)
    return "ID не найден."


# print(m_8_1_3(stdin.read()))


# === Задача 4. Распознать фальшивый файл ===
"""
    Ты нашёл список файлов, загруженных на сервер.
    Некоторые из них опасны, но хакеры научились маскировать поддельные файлы!
    Теперь фальшивые файлы могут:
        - Менять расширение
          (например, virus.txt.exe).
        - Скрывать расширение
          (hacker.dll. –> точка в конце).
        - Имя файла может быть подозрительным
          (password_crack.exe, malware.dll).
    Твоя задача: распознать ВСЕ поддельные файлы!
    Требования к коду:
        1 Получить словарь файлов (ключ=имя файла, значение=расширение).
        2 Определить подозрительные файлы:
            - Файлы с опасными расширениями (.exe, .dll, .bat, .scr).
            - Файлы, маскирующиеся под текстовые (.txt.exe, .doc.dll).
            - Файлы с точкой в конце имени (hacker.dll.).
        3 Вывести список поддельных файлов.
        4 Если нет подозрительных файлов, вывести
          "Поддельные файлы не найдены.".
    """

# import json


def m_8_1_4(data: str):
    files = json.loads(data)
    result = []
    for name, extension in files.items():
        if extension.endswith((".", ".exe", ".dll", ".bat", ".scr")):
            result.append(name)
    if result:
        return f"Поддельные файлы: {', '.join(result)}"
    return "Поддельные файлы не найдены."


# print(m_8_1_4(input()))


# === Задача 5. Взломанный пароль ===
"""
    Ты получил доступ к зашифрованной базе данных хакера,
    где все пароли хранятся в зашифрованном виде.
    Но у тебя есть словарь дешифровки, который поможет
    тебе расшифровать некоторые пароли.
    Однако есть проблема:
        - Некоторые пароли отсутствуют в словаре их нельзя расшифровать.
        - Некоторые пароли содержат поддельные символы (*, #, @)
          их нужно удалить перед дешифровкой.
        - Пароли могут быть маскированными
          (например, p@ssw0rd вместо password).
        - Если пароль неизвестен, вывести "Не удалось расшифровать пароль"
          вместо пароля.
    Требования к коду:
        1 Получить словарь дешифровки
            (ключ=зашифрованный хеш, значение=пароль).
        2 Получить список зашифрованных паролей.
        3 Попытаться расшифровать каждый пароль:
            - Очистить от лишних символов (*, #, @, !, $).
            - Найти в словаре и вывести.
            - Если не найден, вывести "Не удалось расшифровать пароль".
    """

# import json
# import re
# from sys import stdin


def m_8_1_5(data: str):
    line1, line2 = data.strip().split("\n")
    decoder = json.loads(line1)
    passwords = (re.sub(r"[*#@!$]", "", line2)).split()
    result = [
        decoder[password] if password in decoder else "Не удалось расшифровать пароль"
        for password in passwords
    ]
    return " ".join(result)


# print(m_8_1_5(stdin.reads()))


# === Задача 6. Последняя активность ===
"""
    Ты получил лог-файлы о последней активности хакера.
    В этих файлах записаны сайты, которые он посещал и количество заходов.
    Но хакер не глуп! Он использует несколько IP-адресов,
    чтобы запутать следы. Теперь тебе нужно определить:
        - Какой IP-адрес принадлежит хакеру (у него больше всего активности).
        - На каком сайте он сидел дольше всего.
    Требования к коду:
        1 Получить словарь IP-адресов → (ключ=IP, значение=словарь сайтов).
        2 Определить IP с наибольшей активностью.
        3 Найти самый посещаемый сайт этого IP.
        4 Вывести IP-адрес и сайт.
    """

# import json


def m_8_1_6(data: str):
    ips = json.loads(data)
    address = max(ips, key=lambda i: sum((ips[i]).values()))
    sites = ips[address]
    site = max(sites, key=lambda s: sites[s])
    return f"Самый активный IP: {address}\nНаиболее посещаемый сайт: {site}"


# print(m_8_1_6(input()))


# === Задача 7. Декодирование файла ===
"""
    Призрак зашифровал важный .txt-файл, используя нестандартную кодировку.
    Вместо обычного текста в файле хранятся коды (A1, B2, C3...),
    и только специальный словарь может расшифровать их.
    Но есть проблемы:
        - Некоторые коды в файле могут отсутствовать в словаре!
        - В кодах могут быть ошибки или лишние символы!
        - Некоторые коды повторяются, и нужно учитывать их порядок!
    Твоя задача:
        1 Прочитать словарь кодировки (ключ = код, значение = буква).
        2 Прочитать зашифрованный текст (список кодов).
        3 Расшифровать строку (если код есть в словаре, заменить его на букву).
        4 Если код отсутствует в словаре, то заменить его на "?".
    Требования к коду:
        - Получить словарь кодировки ({"A1": "H", "B2": "E"})
        - Получить зашифрованную строку (A1 B2 C3)
        - Расшифровать текст, заменяя коды на буквы
        - Неизвестные коды заменить знаком "?"
        - Вывести итоговое сообщение
    """

# import json
# from sys import stdin


def m_8_1_7(data: str):
    line1, line2 = data.strip().split("\n")
    decoder = json.loads(line1)
    text = line2.strip().split()
    result = (decoder[ch] if ch in decoder else "?" for ch in text)
    return "".join(result)


# print(m_8_1_7(stdin.read()))


# === Задача 8. Ложные личности ===
"""
    Призрак использует несколько ложных аккаунтов,
    чтобы скрывать свои следы в интернете.
    Но он допустил ошибку: он использует один и
    тот же IP-адрес для разных личностей!
    Теперь твоя задача:
        - Найти повторяющийся IP (у нескольких пользователей).
        - Вывести список всех никнеймов, использующих этот IP.
        - Если IP уникальны, то вывести "Призрак не найден".
    Но будь осторожен!
        - Некоторые пользователи могут не иметь IP (пустые строки).
        - IP-адреса могут быть записаны с лишними пробелами, их нужно удалить!
    Требования к коду:
        - Получить словарь (ключ = ник, значение = IP).
        - Удалить пробелы в IP.
        - Найти повторяющийся IP-адрес (который используют несколько никнеймов).
        - Вывести никнеймы и IP-адрес Призрака.
        - Если все IP уникальны --> вывести "Призрак не найден"
    """

# import json


def m_8_1_8(data: str):
    names = json.loads(data)
    ips = {}
    caught_you = None
    for nick, ip in names.items():
        user_ip = ip.strip()
        if user_ip:
            if user_ip in ips:
                if not caught_you:
                    caught_you = user_ip
                ips[user_ip].append(nick)
            else:
                ips[user_ip] = [nick]
    if caught_you:
        return f"Настоящий хакер: {', '.join(ips[caught_you])} (IP: {caught_you})"
    return "Призрак не найден"


# print(m_8_1_8(input()))


# === Задача 9. Финальный след ===
"""
    Ты наконец-то нашёл закодированные координаты
    последнего местоположения Призрака!
    Но он снова попытался тебя запутать:
        - Некоторые даты в хаотичном порядке
        - Некоторые точки повторяются, но их учитывать нельзя!
        - Есть лишние пробелы в местах, их надо убрать!
    Теперь твоя задача:
        - Получить словарь с датами и местами
        - Отсортировать по дате
        - Удалить повторяющиеся локации, но оставить первую встречу
        - Вывести финальный маршрут
    Требования к коду:
        - Получить словарь (ключ = дата, значение = место).
        - Удалить пробелы в местах (" Париж " → "Париж").
        - Отсортировать по дате (по ключу словаря).
        - Удалить повторяющиеся локации, но оставить первую встречу.
        - Вывести финальный маршрут (Город → Город → Город).
    """


# import json


def m_8_1_9(data: str):
    locations = json.loads(data)
    result = []
    for date in sorted(locations.keys()):
        location = locations[date].strip()
        if location not in result:
            result.append(location)
    return f"Маршрут: {' → '.join(result)}"


# print(m_8_1_9(input()))


# === Задача 10. Захват Призрака ===
"""
    Ты вычислил финальное укрытие Призрака.
    Но он снова применил поддельные маршруты и двойные личности!
    Ты получил два словаря:
        1 Реальные передвижения (ключ = дата, значение = город)
        2 Ложные маршруты (ключ = дата, значение = поддельный город)
    - Призрак пойман там, где его настоящий маршрут не совпадает с ложным.
    - Если во всех датах совпадения, значит, он снова скрылся...
    Требования к коду:
    - Получить два словаря:
            реальные передвижения ({дата: город})
            ложные маршруты ({дата: город})
    - Найти первую дату, где данные не совпадают (место, где он действительно был!).
    - Вывести город, где его нашли или "Призрак снова скрылся...".
    """

# import json
# from sys import stdin


def m_8_1_10(data: str):
    line1, line2 = data.strip().split("\n")
    real, unreal = json.loads(line1), json.loads(line2)
    for date, city in real.items():
        if city != unreal[date]:
            return f"🔥 Призрак пойман в городе: {city}!"
    return "👻 Призрак снова скрылся..."


# print(m_8_1_10(stdin.read()))
