# Stepick.org — PROкод: продвинутый курс по Python
# 9. Работа с множествами (set)

from sys import stdin


# pylint: disable=W0105

# 9.1  Множества: Особенности и основные характеристики


# === Задача 1. Магическое множество чисел  ===
"""
    Шаг 1. Считайте одну строку с числами, разделёнными пробелами.
    Шаг 2. Преобразуйте введённые значения в множество (повторы удаляются).
    Шаг 3. Найдите минимальное и максимальное число в этом множестве
            и вычислите их сумму.
    Шаг 4. Выведите результат. Округлить до 2х знаков после запятой!
    """


def m_9_1_1(data: str):
    nums = set(map(float, data.split()))
    result = min(nums) + max(nums)
    return f"Сумма минимального и максимального числа: {round(result, 2)}"


# print(m_9_1_1(input()))


# === Задача 2. Уникальные обитатели волшебного леса  ===
"""
    Шаг 1. Считайте первую строку —> список обитателей
            (слова через пробел), в котором возможны повторы.
    Шаг 2. Преобразуйте список в множество, чтобы удалить дубликаты.
    Шаг 3. Выведите количество уникальных обитателей в формате:
            Количество уникальных обитателей в Лесном Реестре: <число>
    Шаг 4. Считайте вторую строку —> имя обитателя для проверки.
            Если имя есть среди уникальных, выведите:
                Обитатель '<имя>' зарегистрирован.
            иначе выведите:
                Обитатель '<имя>' не зарегистрирован.
    """


# from sys import stdin


def m_9_1_2(data: str):
    line1, name = data.strip().split("\n")
    dwellers = set(line1.split())
    return (
        f"Количество уникальных обитателей в Лесном Реестре: {len(dwellers)}\n"
        f"Обитатель '{name}' {'' if name in dwellers else 'не '}зарегистрирован."
    )


# print(m_9_1_2(stdin.read()))


# === Задача 3. Уникальны ли цифры свитка  ===
"""
    Шаг 1. Считайте одну строку, состоящую из цифр.
    Шаг 2. Проверьте, встречаются ли какие-либо цифры более одного раза.
    Шаг 3. Выведите Да, если все цифры уникальны; иначе выведите Нет.
    """


def m_9_1_3(data: str):
    nums = tuple(map(int, data))
    return "Да" if len((nums)) == len(set(nums)) else "Нет"


# print(m_9_1_3(input()))


# === Задача 4. Совпадают ли наборы цифр  ===
"""
    Шаг 1. Считайте две строки, каждая состоит из цифр.
    Шаг 2. Определите наборы цифр, использованных в каждой строке
            (без учёта порядка и количества повторов).
    Шаг 3. Выведите Да, если наборы совпадают, иначе выведите Нет.
    """


# from sys import stdin


def m_9_1_4(data: str):
    nums1, nums2 = (set(map(int, line)) for line in data.strip().split("\n"))
    return "Да" if nums1 == nums2 else "Нет"


# print(m_9_1_4(stdin.read()))


# 9.2  Множества: Основные операции и функции


# === Задача 1. Уникальные зрители кинотеатра  ===
"""
    Шаг 1. Считайте все строки входных данных,
        каждая строка содержит имя зрителя.
    Шаг 2. Определите, сколько уникальных имён
        встретилось во всём списке.
    Шаг 3. Выведите единственное число, общее
        количество уникальных зрителей.
    """

# from sys import stdin


def m_9_2_1(data: str):
    lst = list(map(str.strip, data.strip().split()))
    return len(set(lst))


# print(m_9_2_1(stdin.read()))


# === Задача 2. Ресурсы после ядерной войны  ===
"""
    Шаг 1. Считайте одну строку, содержащую названия ресурсов,
    разделённые символом ;. Пробелы вокруг названий следует игнорировать.
    Шаг 2. Определите множество уникальных ресурсов (без повторов).
    Шаг 3. Найдите:
        — общее количество уникальных ресурсов;
        — самый ценный ресурс --> с максимальной длиной названия;
        — самый редкий ресурс --> с минимальной длиной названия;
        — суммарную «ценность» --> сумму длин всех уникальных названий.
    Шаг 4. Выведите результаты строго в формате строк (каждую с новой строки):
        Общее количество уникальных ресурсов: <число>
        Самый ценный ресурс: <ресурс>
        Самый редкий ресурс: <ресурс>
        Суммарная ценность ресурсов: <число>
        Ресурсы в отсортированном порядке: <ресурс1, ресурс2, ...>
    Ресурсы в последней строке должны быть отсортированы по возрастанию длины
    названия; при равной длине в алфавитном порядке.
    Список выводите через запятую и пробел.
    """


def m_9_2_2(data: str):
    resources = [res.strip() for res in data.split(";")]
    uniq_res = sorted(set(resources), key=lambda r: (len(r), r))
    result = []
    result.append(f"Общее количество уникальных ресурсов: {len(uniq_res)}")
    result.append(f"Самый ценный ресурс: {max(uniq_res, key=len)}")
    result.append(f"Самый редкий ресурс: {min(uniq_res, key=len)}")
    result.append(f"Суммарная ценность ресурсов: {sum(map(len, uniq_res))}")
    result.append(f"Ресурсы в отсортированном порядке: {', '.join(uniq_res)}")
    return "\n".join(result)


# print(m_9_2_2(input()))


# === Задача 3. Зашифрованный сигнал с планеты Алтариус  ===
"""
    Шаг 1. Считайте одну строку текста
        (возможны латинские буквы, пробелы, цифры и другие символы).
    Шаг 2. Выделите все цифры от 0 до 9, которые встречаются в строке
         оставив каждую только один раз.
    Шаг 3. Отсортируйте найденные цифры по возрастанию и выведите
        их через пробел в одной строке.
    Шаг 4. Если в строке нет цифр, выведите ровно: Цифр нет.
    """


def m_9_2_3(data: str):
    nums = sorted(num for num in set(data) if num.isdigit())
    if nums:
        return " ".join(nums)
    return "Цифр нет"


# print(m_9_2_3(input()))


# === Задача 4. Платформа «JobTalk»: уникальные кандидаты  ===
"""
    Шаг 1. Входные данные состоят из нескольких строк формата
        имя кандидата: комментарий
        (имя может содержать пробелы; комментарий --> любые символы).
    Шаг 2. Для каждой строки выделите имя кандидата как подстроку до
        первого символа : (пробелы по краям имени игнорируйте).
    Шаг 3. Определите количество уникальных имён кандидатов
        и выведите одно число.
    """

# from sys import stdin


def m_9_2_4(data: str):
    names = set(line[: line.index(":")].strip() for line in data.strip().split("\n"))
    return len(names)


# print(m_9_2_4(stdin.read()))


# === Задача 5. Дезоксирибонуклеиновая кислота  ===
"""
    Шаг 1. Считайте одну строку, состоящую из заглавных латинских букв.
        Допускаются любые буквы, не только A, C, G, T.
    Шаг 2. Проверьте, содержит ли строка все четыре символа A, C, G, T
        хотя бы по одному разу.
    Шаг 3. Выведите YES, если все символы присутствуют, иначе выведите NO.
    """


def m_9_2_5(data: str):
    test_set = {"A", "C", "G", "T"}
    dna = set(ch for ch in data if ch in test_set)
    return "YES" if test_set == dna else "NO"


# print(m_9_2_5(input()))


# 9.3 Методы добавления и удаления элементов в множества


# === Задача 1.Древние руины ===
"""
    Шаг 1. Считайте натуральное число N --> количество мест раскопок.
    Шаг 2. Считайте следующие N строк. Каждая строка содержит
           номера артефактов, разделённые пробелами.
    Шаг 3. Определите общее число различных (уникальных) номеров артефактов,
           встречающихся хотя бы в одном месте.
    Шаг 4. Выведите единственное число --> количество уникальных артефактов.
    """

# from sys import stdin


def m_9_3_1(data: str):
    artifacts = set(num for line in data[1:].split("\n") for num in line.split())
    return len(artifacts)


# print(m_9_3_1(stdin.read()))


# === Задача 2. Управление списком/множеством участников ===
"""
    Шаг 1. Создайте начальное множество участников: {1, 2, 3, 4, 5}.
    Шаг 2. Считайте три строки входных данных:
        - первая строка --> номера новых участников через пробел
          (добавьте их во множество);
        - вторая строка --> номер участника, которого нужно удалить
          методом remove();
        - третья строка --> номер участника, которого нужно удалить
          методом discard().
    Шаг 3. Удалите одного случайного участника методом pop()
           и выведите его номер отдельной строкой.
    Шаг 4. Очистите множество методом clear().
    Шаг 5. После каждого шага выведите результат строго в
           таком порядке и формате:
            - После добавления участников: {…}
            - После удаления участника с номером X: {…}
            - После удаления участника с номером Y (метод discard): {…}
            - Удалён случайный участник с номером Z.
            - Оставшиеся участники: {…}
            - После очистки списка участников: set()
    Формат отображения множества: элементы по возрастанию, в фигурных скобках,
        разделены запятой и пробелом (как в примере).
    """

# from sys import stdin


def m_9_3_2(data: str):
    lines = data.strip().split("\n")
    participants = {1, 2, 3, 4, 5}
    new_users = set(map(int, lines[0].split()))
    to_remove, to_discard = map(int, lines[1:])
    result = []
    participants |= new_users
    result.append(f"После добавления участников: {set(sorted(participants))}")
    participants.remove(to_remove)
    result.append(
        f"После удаления участника с номером {to_remove}: {set(sorted(participants))}"
    )
    participants.discard(to_discard)
    result.append(
        f"После удаления участника с номером {to_discard} (метод discard): {set(sorted(participants))}"
    )
    pop_i = participants.pop()
    result.append(f"Удалён случайный участник с номером {pop_i}.")
    result.append(f"Оставшиеся участники: {set(sorted(participants))}")
    participants.clear()
    result.append(f"После очистки списка участников: {participants}")
    return "\n".join(result)


# print(m_9_3_2(stdin.read()))


# === Задача 3. Склад автомобилей ===
"""
    Шаг 1. Считайте целое число N --> количество операций.
    Шаг 2. Затем обработайте N строк, каждая из которых --> одна из команд:
        - add X --> добавить идентификатор X в набор;
        - remove X --> удалить X из набора
          (если X отсутствует, возникает ошибка);
        - discard X --> удалить X, если он есть (ошибки не возникает);
        - pop --> удалить (и вернуть) случайный элемент набора
          (если набор пуст, возникает ошибка);
        - clear --> полностью очистить набор.
    Шаг 3. По завершении всех операций выведите содержимое набора.
        - Если набор пуст, выведите ровно: Множество пустое.
        - Если не пуст, выведите элементы одной строкой, разделяя пробелом.
    """

# from sys import stdin


def m_9_3_3(data: str):
    auto_ids = set()
    commands = data.strip().split("\n")[1:]
    for line in commands:
        command, *auto_id = line.split()
        match command:
            case "add":
                auto_ids.add(auto_id[0])
            case "remove":
                auto_ids.remove(auto_id[0])
            case "discard":
                auto_ids.discard(auto_id[0])
            case "pop":
                auto_ids.pop()
            case "clear":
                auto_ids.clear()
    if auto_ids:
        return " ".join(sorted(auto_ids))
    else:
        return "Множество пустое"


# print(m_9_3_3(stdin.read()))


# === Задача 4. Фруктовый сад ===
"""
    Шаг 1. Изначальное множество фруктов (ровно 20 штук), в программе уже есть:
        {"apple", "pear", "peach", "plum", "cherry",
        "banana", "orange", "lime", "lemon", "grapefruit",
        "mango", "papaya", "pineapple", "kiwi", "strawberry",
        "blueberry", "raspberry", "grape", "melon", "watermelon"}
    Шаг 2. Считайте целое число N --> количество операций.
    Шаг 3. Обработайте последующие N строк-команд:
        - add X --> добавить фрукт X в множество;
        - remove X --> удалить X из множества
                    (если X отсутствует, возникает ошибка);
        - discard X --> удалить X, если он есть (ошибки не возникает);
        - pop --> удалить (и вернуть) случайный элемент множества
                    (если множество пусто, возникает ошибка);
        - clear --> полностью очистить множество.
    Шаг 4. По завершении всех операций:
        - если множество пусто, выведите: Фруктовый сад пуст;
        - иначе выведите все оставшиеся фрукты одной строкой через пробел,
          отсортировав их в лексикографическом порядке.
    """

# from sys import stdin


def m_9_3_4(data: str):
    orchard = {
        "apple",
        "pear",
        "peach",
        "plum",
        "cherry",
        "banana",
        "orange",
        "lime",
        "lemon",
        "grapefruit",
        "mango",
        "papaya",
        "pineapple",
        "kiwi",
        "strawberry",
        "blueberry",
        "raspberry",
        "grape",
        "melon",
        "watermelon",
    }
    commands = data.strip().split("\n")[1:]
    for line in commands:
        command, *fruit = line.split()
        match command:
            case "add":
                orchard.add(fruit[0])
            case "remove":
                orchard.remove(fruit[0])
            case "discard":
                orchard.discard(fruit[0])
            case "pop":
                orchard.pop()
            case "clear":
                orchard.clear()
    if orchard:
        return " ".join(sorted(orchard))
    else:
        return "Фруктовый сад пуст"


# print(m_9_3_4(stdin.read()))


# 9.4  Методы объединения, пересечения и разности множеств


# === Задача 1. Выборы в королевстве ===
"""
    Шаг 1. Считайте три строки входных данных:
        - первая --> номера сторонников партии собак (через пробел),
        - вторая --> партии кошек,
        - третья --> партии попугаев.
        Каждая строка формирует множество (повторы в строке игнорируются).
        Пустая строка означает пустое множество.
    Шаг 2. Выведите сами множества сторонников в точности в таком формате
        - элементы по возрастанию, через запятую и пробел;
        - пустое множество как set()):
            - Сторонники партии собак: {…}
            - Сторонники партии кошек: {…}
            - Сторонники партии попугаев: {…}
    Шаг 3. Выведите количества сторонников в каждой партии:
        - Общее количество сторонников партии собак: <число>
        - Общее количество сторонников партии кошек: <число>
        - Общее количество сторонников партии попугаев: <число>
    Шаг 4. Выведите попарные пересечения
        (тот же формат множества, элементы по возрастанию):
            - Общие сторонники между собаками и кошками: {…}
            - Общие сторонники между собаками и попугаями: {…}
            - Общие сторонники между кошками и попугаями: {…}
    Шаг 5. Определите победителя по наибольшему числу сторонников
        и выведите одну из строк:
            - Победила партия собак с наибольшим количеством сторонников! 🐶🎉
            - Победила партия кошек с наибольшим количеством сторонников! 🐱🎉
            - Победила партия попугаев с наибольшим количеством сторонников! 🦜🎉
    Если все три партии набрали одинаковое количество сторонников, выведите:
        Ой-ой! Похоже, выборы были отменены!
        Все партии набрали одинаковое количество сторонников! 😹
    """

# from sys import stdin


def m_9_4_1(data: str):
    def sorted_set(s: set):
        if s:
            return "{" + str(sorted(s))[1:-1] + "}"
        return str(s)

    dogs, cats, parrots = (
        set(int(num) for num in line.split()) for line in data.strip().split("\n")
    )
    parties = [
        {
            "supporters": dogs,
            "len": len(dogs),
            "message": "собак",
            "smile": "🐶",
        },
        {
            "supporters": cats,
            "len": len(cats),
            "message": "кошек",
            "smile": "🐱",
        },
        {
            "supporters": parrots,
            "len": len(parrots),
            "message": "попугаев",
            "smile": "🦜",
        },
    ]
    result = []
    for p in parties:
        result.append(
            f"Сторонники партии {p['message']}: {sorted_set(p['supporters'])}"
        )
    for p in parties:
        result.append(f"Общее количество сторонников партии {p['message']}: {p['len']}")

    common = "Общие сторонники между"
    result.extend(
        (
            f"{common} собаками и кошками: {sorted_set(dogs & cats)}",
            f"{common} собаками и попугаями: {sorted_set(dogs & parrots)}",
            f"{common} кошками и попугаями: {sorted_set(cats & parrots)}",
        )
    )
    if len(dogs) == len(cats) == len(parrots):
        result.append(
            "Ой-ой! Похоже, выборы были отменены! "
            "Все партии набрали одинаковое количество сторонников! 😹"
        )
    else:
        winner = max(parties, key=lambda p: p["len"])
        result.append(
            f"Победила партия {winner['message']} с наибольшим количеством "
            f"сторонников! {winner['smile']}🎉"
        )
    return "\n".join(result)


# print(m_9_4_1(stdin.read()))


# === Задача 2. Кто хочет стать миллионером ===
"""
    Шаг 1. Считайте две строки:
        — первая строка --> список всех участников шоу
          (имена через запятую),
        — вторая строка --> список участников, прошедших первый тур
          (имена через запятую).
        Пробелы вокруг имён игнорируйте; повторы в пределах одной
        строки учитываются как одно имя (используйте множество).
    Шаг 2. Постройте два множества и вычислите:
        - «кто был на шоу, но не прошёл первый тур» -->
          разность множеств (все -- прошедшие),
        - «кто пришёл и прошёл» --> пересечение,
        - «все, кто хотя бы раз был на шоу» --> объединение,
        - «кто пришёл, но не прошёл, и наоборот» --> симметрическую разность.
    Шаг 3. Выведите ровно четыре строки в точности в таком формате
        (элементы отсортированы по алфавиту, разделитель --> , ;
        если множество пусто, после двоеточия ничего не выводите):
            1. Кто был на шоу, но не прошел первый тур:
                <имена по возрастанию>
            2. Кто пришел на шоу и прошел первый тур:
                <имена по возрастанию>
            3. Все, кто хотя бы один раз был на шоу:
                <имена по возрастанию>
            4. Кто пришел на шоу, но не прошел тур, и наоборот:
                <имена по возрастанию>
    """

# from sys import stdin


def m_9_4_2(data: str):
    participants, second_round = (
        set(name.strip() for name in line.split(","))
        for line in data.strip().split("\n")
    )
    result = [
        "1. Кто был на шоу, но не прошел первый тур: "
        f"{', '.join(sorted(participants - second_round))}",
        "2. Кто пришел на шоу и прошел первый тур: "
        f"{', '.join(sorted(participants & second_round))}",
        "3. Все, кто хотя бы один раз был на шоу: "
        f"{', '.join(sorted(participants | second_round))}",
        "4. Кто пришел на шоу, но не прошел тур, и наоборот: "
        f"{', '.join(sorted(participants ^ second_round))}",
    ]
    return "\n".join(result)


# print(m_9_4_2(stdin.read()))


# 9.5 Методы множеств: Подмножества, Надмножества и Сравнение


# === Задача 1. Отделы A и B ===
"""
    Шаг 1. Считайте целое число N --> количество сотрудников в отделе «A».
    Шаг 2. Считайте следующую строку из N имён (через пробел)
        и сформируйте множество A (повторы игнорируются).
    Шаг 3. Считайте целое число M --> количество сотрудников в отделе «B».
    Шаг 4. Считайте следующую строку из M имён (через пробел)
        и сформируйте множество B.
    Шаг 5. Проверьте и выведите ровно три строки в указанном формате:
        A is subset of B? <True/False>
        B is superset of A? <True/False>
        A and B are disjoint? <True/False>
    Где:
        A.issubset(B) --> подмножество,
        B.issuperset(A) --> надмножество,
        A.isdisjoint(B) --> множества не имеют общих элементов.
    Ограничение: не используйте sorted, list, dict, range
    """

# from sys import stdin


def m_9_5_1(data: str):
    set_a, set_b = (
        set(name.strip() for name in line.split()) for line in data.split("\n")[1::2]
    )
    result = [
        f"A is subset of B? {set_a.issubset(set_b)}",
        f"B is superset of A? {set_b.issuperset(set_a)}",
        f"A and B are disjoint? {set_a.isdisjoint(set_b)}",
    ]
    return "\n".join(result)


# print(m_9_5_1(stdin.read()))


# === Задача 2. Охота на вампиров ===
"""
    Шаг 1. Считайте две строки:
        - первая --> имена первой группы,
        - вторая --> имена второй группы.
        Имена в каждой строке перечислены через запятую.
    Шаг 2. Преобразуйте каждую строку в множество имён:
        - пробелы вокруг имён игнорируйте;
        - повторы внутри одной строки не учитывайте.
    Шаг 3. Определите отношения между группами и
        выведите ровно одну из строк (без кавычек):
        - Первая группа - подмножество второй.
        - Вторая группа - подмножество первой.
        - Группы не пересекаются.
        - Группы пересекаются, но ни одна не является подмножеством другой.
    """

# from sys import stdin


def m_9_5_2(data: str):
    set1, set2 = (
        set(name.strip() for name in line.split(","))
        for line in data.strip().split("\n")
    )
    match True:
        case _ if set1.issubset(set2):
            return "Первая группа - подмножество второй."
        case _ if set1.issuperset(set2):
            return "Вторая группа - подмножество первой."
        case _ if set1.isdisjoint(set2):
            return "Группы не пересекаются."
        case _:
            return "Группы пересекаются, но ни одна не является подмножеством другой."


# print(m_9_5_2(stdin.read()))


# === Задача 3. Тайный шифр охотников ===
"""
    Шаг 1. Считайте две строки:
        - первая --> последовательность символов первого свитка,
        - вторая --> последовательность символов второго свитка.
        Символы в каждой строке разделены пробелами.
        Пустая строка означает пустую последовательность.
    Шаг 2. Определите отношения между свитками и выведите ровно одну из строк:
        - Первый свиток скрыт в тексте второго.
            --> если все символы первого встречаются во втором
                в том же порядке (между ними могут быть другие символы).
        - Второй свиток скрыт в тексте первого.
            --> если все символы второго встречаются в первом в том же порядке.
        - Свитки имеют общие символы, но их порядок различен.
            --> если ни один не является подпоследовательностью другого,
                но есть хотя бы один общий символ.
        - Свитки принадлежат разным эпохам.
            --> если общих символов нет вовсе.
    Порядок проверки:
        - сначала проверяйте, скрыт ли первый во втором;
        - затем --> второй в первом; затем наличие общих символов;
        - затем --> отсутствие общих символов.
    """


# from sys import stdin


def m_9_5_3(data: str):
    def is_subset(sub_array, array):
        iterator = iter(array)
        return all(char in iterator for char in sub_array)

    scroll1, scroll2 = (list(line.strip().split()) for line in data.strip().split("\n"))
    match True:
        case _ if is_subset(scroll1, scroll2):
            return "Первый свиток скрыт в тексте второго."
        case _ if is_subset(scroll2, scroll1):
            return "Второй свиток скрыт в тексте первого."
        case _ if set(scroll1).isdisjoint(scroll2):
            return "Свитки принадлежат разным эпохам."
        case _:
            return "Свитки имеют общие символы, но их порядок различен."


# print(m_9_5_3(stdin.read()))
